# 문제
링크 : https://www.acmicpc.net/problem/15990
해결여부 : yes

# 코드
```
import sys
input = sys.stdin.readline

t = int(input())
dp = [[0, 0, 0] for _ in range(100001)]
dp[1] = [1, 0, 0]
dp[2] = [0, 1, 0]
dp[3] = [1, 1, 1]

for i in range(4, 100001):
    dp[i] = [(dp[i-1][1] + dp[i-1][2]) % 1000000009, (dp[i-2][0] + dp[i-2][2]) % 1000000009, (dp[i-3][0] + dp[i-3][1]) % 1000000009]

for _ in range(t):
    a = int(input())
    print(sum(dp[a]) % 1000000009)
```

# 문제 풀이
어떤 숫자를 1, 2, 3의 합으로 표현하되, 같은 숫자를 연속해서 2번 더할 수 없다. 예컨대 2를 표현할 때 `1+1`로 표현할 수 없고, 4를 표현할 때 `2+1+1`로 표현할 수 없다.

어떤 숫자 n을 1, 2, 3의 합으로 표현하려면 `n-1`에 1을 더하는 방법, `n-2`에 2를 더하는 방법, `n-3`에 3을 더하는 방법이 있을 것이다. 이 때 각각의 이전 수들의 마지막 숫자가 각각 1, 2, 3이 있을 수 있으므로 그냥 단순히 이런 식으로는 구할 수 없다.

나는 세 가지로 경우를 나누어서 생각했다. 어차피 앞에 어떤 식으로 더해지든, 우리가 신경쓸 부분은 마지막 숫자가 무엇인가이다. 오직 마지막 숫자만이 다음 수를 표현할 때 제약사항이 되기 때문이다.

`dp` 배열을 선언하기를, '어떤 수 n을 표현할 수 있는 방법의 가짓수를 저장하되, `마지막 숫자가 1인 방법`, `마지막 숫자가 2인 방법`, `마지막 숫자가 3인 방법`으로 나누어서 저장한다고 하자. 예컨대 1을 표현하는 방법은 '1' 하나이므로, `dp[1] = [1, 0, 0]` (마지막 숫자가 1인 경우의 수가 1, 나머지는 0)이다. 문제에서 주어진 예시로 4를 표현하는 방법은 `1+2+1`, `1+3`, `3+1` 3가지이다. 즉 `dp[4] = [2, 0, 1]`이 된다.

그렇다면, 점화식을 세워 보자.

앞서 n을 표현하기 위해서, n-1에 1을 더하는 방법, n-2에 2를 더하는 방법, n-3에 3을 더하는 방법이 있다고 하였다. 이를 좀 더 엄밀히 말하자면, `마지막 숫자로써 2, 3이 오면서 n-1을 표현하는 방법` 에 1을 더하는 방법, `마지막 숫자로써 1, 3이 오면서 n-2을 표현하는 방법`에 2를 더하는 방법, `마지막 숫자로써 1, 2가 오면서 n-3을 표현하는 방법` 에 3을 더하는 방법이라고 할 수 있다. 

`마지막 숫자로써 2, 3이 오면서 n-1을 표현하는 방법` 을 `dp`로 표현하면 `dp[n-1][1] + dp[n-1][2]`가 될 것이다. 이제 점화식을 세울 수 있다.

> dp[i] = [(dp[i-1][1] + dp[i-1][2]), (dp[i-2][0] + dp[i-2][2]), (dp[i-3][0] + dp[i-3][1])]

이를 통해서 `dp[100000]`까지를 미리 구해놓고, 입력받은 수 a에 대해 `dp[a]`를 출력한다. 이 때 연산 속도 향상을 위해서 출력에서뿐만 아니라 저장할 때도 `1,000,000,009로 나눈 나머지`로 저장한다.


# 부족했던 점

# 마무리
어떤 동작을 연속으로 할 수 없다는 제약 조건이 있을 때는 한 단계 더 이전의 경우에서부터 시작하는 방법이 있을 수 있다. 또한 이렇게 각각의 경우의 수를 따로 저장함으로써 제약조건에서 자유로워지는 방법도 있다. (점화식이 여러 번의 덧셈으로 이루어져 조금 길어지긴 하지만)