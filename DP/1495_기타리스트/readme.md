# 문제
링크 : https://www.acmicpc.net/problem/1495
해결여부 : no

# 코드
```
n, s, m = map(int, input().split())
v = list(map(int, input().split()))
dp = [[0] * (m+1) for _ in range(n+1)]
dp[0][s] = 1

for i in range(n):
    for j in range(m+1):
        if dp[i][j] == 1:
            if j+v[i] <= m:
                dp[i+1][j+v[i]] = 1
            if j-v[i] >= 0:
                dp[i+1][j-v[i]] = 1

ans = -1
for i in range(m, -1, -1):
    if dp[n][i]==1:
        ans = i
        break
print(ans)
```

# 문제 풀이
`dp` 리스트를 정의하기를, `dp[i][j]`를 `i번째 곡을 볼륨 j로 연주할 수 있는지 여부` 로 정의한다.
그러면 최대 볼륨(m) x 곡 수(n)의 2차원 리스트가 만들어지게 되고, 초기 시작값을 `dp[0]`에 넣어준다. 그 후, `dp[1]`부터 `dp[n]` 까지 `i`로 탐색하되 `dp[i]`에 대하여 `dp[i-1]이 참인 칸을 발견하면, 그 칸의 볼륨을 더하고 뺀 값 중 바운더리 안에 속한 값에 해당하는 인덱스를 참으로 만들어준다. 몇 번만에 연주할 수 있고 이런 것을 묻는 것이 아니라, 연주할 수 있는지 없는지 True/False만 있으면 된다.

그러면 dp[n]까지, 연주할 수 있는 볼륨이라면 True, 즉 1이 저장되어 있을 것이고, 이를 거꾸로 큰 볼륨부터 탐색하여 가장 처음 나오는 True의 인덱스가 바로 최댓값이 된다.
만약 하나도 True가 없다면, 연주할 수 없다는 뜻이고, 이를 별도의 추가 작업 없이 나타내기 위해 `ans`의 초기값을 -1로 초기화해준다.


# 부족했던 점
풀 당시에 두 가지 해결법을 떠올렸다. 첫 번째로는 똑같이 2차원 리스트를 사용하되 연주할 수 있는 볼륨을 모두 `append` 하는 것이었다. 처음에 `dp[0]`에 `s`를 넣어두고, `dp[1]`부터, 이전의 모든 `dp[0]`의 원소에 대하여 플러스 마이너스한 값을 범위 확인 후 넣어주는 것이다. 두 번째는 `BFS`를 사용하는 방법이었는데 몇 번째 곡인지의 변수와 볼륨 값을 같이 큐에 저장하고, 큐에서 빼낸 값에서 볼륨을 더하고 뺀 값을 번째수를 +1 하여 저장하고, 마지막 n에 다다르면 빼는 족족 리스트에 옮겨담아서 마지막에 최댓값을 구했다.

두 가지 방법 모두, 볼륨의 값이 매우 작고 최대 볼륨이 매우 큰 경우에 (즉, 커버할 수 있는 범위가 넓을 경우에) 음악이 거듭될수록 약 2배씩 늘어나서 `2^N`개의 원소를 커버해야 하는 경우가 생긴다.

이런 문제가 있다는 것을 생각은 했었는데 해결하기가 힘들어서, top-down 방식으로도 풀어보려고 했으나 여의치 않아서 해답을 찾아보게 되었다...

# 마무리
`dp`를 2차원으로 만드는 것에 대한 생각이 부족하다.