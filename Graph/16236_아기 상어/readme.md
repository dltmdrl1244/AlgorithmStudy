# 문제
링크 : https://www.acmicpc.net/problem/16236
해결여부 : No

# 문제 풀이
가장 먼저 9인 칸을 찾아서 0으로 만든 후에 현재 상어의 좌표를 기록한다.
그리고 BFS를 사용해 가장 가까이 있는 먹이를 찾는다. 구체적인 BFS 사용이 살짝 까다롭다.
먼저, `이동할 수 있는 칸` 에 대하여 즉 큐에 `append` 하는 조건에 대해서는 상어의 크기보다 작거나 같은 물고기가 있는 칸, 혹은 비어있는 칸으로만 이동할 수 있다. 그러한 칸이 발견되면 먼저 무한루프를 방지하기 위해 `visited` 정보를 갱신하고 좌표 정보를 큐에 저장하고, 거리 정보를 갱신한다. 거리 정보는 이전 칸의 거리 정보 + 1이다. (거리 정보는 2차원 리스트로 다룬다.)
그리고 `먹을 수 있는 먹이가 있는 칸` 에 대해서 `fish` 라는 리스트에다 담을 것이다. (첫 물고기를 발견하고 바로 리턴하지 않는 이유는 같은 거리 상의 물고기들에 대하여 우선순위가 있기 때문에 추후에 물고기들 중 좌표를 정렬하여 1순위 물고기를 리턴해야 하기 때문이다.) 먼저 크기가 상어보다 작아야 하고, 최단거리 상에 위치해야 한다. 이 때는 `minDist` 라는 변수를 사용하여 현재 가장 가까운 거리보다 더 멀리 있는 먹을 수 있는 물고기에 대해서는 건너뛸 수 있게 한다.
`fish` 리스트가 비어 있다면 먹을 수 있는 물고기가 없다는 뜻이므로 -1을 리턴하고, 만약 둘 이상이라면 그 중에서 먹을 물고기를 찾아야 한다. 문제에서 가장 위에, 가장 오른쪽에 있는 물고기를 먹는다고 하였으므로 y좌표, x좌표 차례로 정렬해준 후에 가장 첫 번째 원소가 바로 `이번 차례에 먹을 물고기의 좌표` 가 된다. 좌표와 그 좌표까지 가는 데에 최단거리, 즉 `distance` 리스트 값을 리턴한다.

그리고 함수 바깥에서는 리턴받은 물고기의 좌표를 이용해서, 상어의 위치를 갱신하고, 물고기를 먹었으니 칸을 0으로 만들고, 상어가 먹은 물고기 수와 크기를 다뤄준다. (`sharkExp` 변수를 1씩 늘리고, `shark`와 같아지면 크기를 키우고 `sharkExp`를 0으로 만든다) 그리고 거리 정보를 `result`에 더해준다. 좌표 정보가 -1, -1이라면 먹을 수 있는 물고기가 없다는 뜻이므로 무한루프문을 탈출한다.

# 부족했던 점
몇몇 테스트케이스에 대해 결과값이 다르게 출력되는 경우가 있었다. 같은 거리 다른 위치에 있는 먹을 수 있는 물고기들에 대하여 상, 좌, 우, 하 순서대로 탐색하고 큐에서 나오는 순서대로만 처리를 했었는데, 단순히 그렇게 하면 예를 들어서 왼쪽 아래에 있는 물고기와 오른쪽으로 두 칸 떨어져 있는 물고기 중에서 오른쪽 두 칸 떨어진 물고기를 먹어야 하는데 탐색 순서에 따라서 왼쪽 아래에 있는 물고기를 먹게 돼버렸다.

처음에는 `bfs` 함수 내에서 먹을 물고기 위치를 찾고, 먹고, 성장하고 등등의 모든 과정이 진행되었는데 그러다보니 큐가 엄청나게 쌓여서, 이것을 그때그때 비워주기도 뭐하고 그렇다고 정렬하기에는 불순물들이 섞여있고 해서 고민이 많았는데, `bfs` 함수에서 그냥 위치 정보만 리턴해주고 함수 외부에서 처리해주면 되는 것이었다. 함수 하나하나에 기능을 많이 넣지 않는 것이 좋다는 것을 배웠다.