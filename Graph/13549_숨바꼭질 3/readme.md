# 문제
링크 : https://www.acmicpc.net/problem/13549
해결여부 : no

# 코드
```
from collections import deque
check = [False] * 100002
dist = [-1] * 100002

n,k = map(int, input().split())

def bfs(n, k):
    q = deque()
    q.append(n) 

    cnt = [-1 for _ in range(100001)]
    cnt[n] = 0
    
    while q:
        s = q.popleft()
        if s == k:
            return cnt[s]
        if 0 <= s-1 < 100001 and cnt[s-1] == -1:
            cnt[s-1] = cnt[s] + 1
            q.append(s-1)
        if 0 < s*2 < 100001 and cnt[s*2] == -1:
            cnt[s*2] = cnt[s]
            q.appendleft(s*2)
        if 0 <= s+1 < 100001 and cnt[s+1] == -1:
            cnt[s+1] = cnt[s] + 1
            q.append(s+1)

print(bfs(n, k))
```

# 문제 풀이
기존 BFS와는 살짝 다르게 `0-1 BFS` 라는 개념을 사용하는 문제이다.
0-1 BFS는 가중치가 0과 1로만 주어진 그래프에서 최단 경로를 찾고자 할 때 응용할 수 있다.

방문 횟수의 최소가 아니라 가중치(비용)의 최소를 찾아야 하는 경우 가중치가 0인 경로를 적극 활용해야 하므로, 우선 순위를 높게 해주어야 한다고 한다. 즉 기존 BFS와는 조금 다르게, `큐의 앞`에다가 삽입한다. (위 코드의 `appendleft`)

그 외에는 일반 BFS와 비슷하다.

# 부족했던 점
이전에 풀었던 숨바꼭질의 변형 문제로, 이 문제에서는 순간이동하는 경우에는 시간 소요가 없다.
그냥 큐에 추가할 때 카운트를 +1 해주지 않고 그냥 넣으면 되지 않을까 했는데 오답이 나왔다.
뭐가 문제인지 잘 모르겠어서 질문 게시판을 보던 중 `최초로 그 칸에 도착했다고 하여 최적해가 아니다` 라는 것을 알게 되었고 예를 들어 `4 6` input의 경우 정답은 4->3->6 으로 1이지만 4->5->6 으로 2가 출력될 수 있다는 것을 알았다.

그래서 도착지점에 도착했을 때 이전 해보다 작은 해라면 교체해주는 식으로 생각했었는데, 그렇다면 언제 끝마쳐야 할 것인지 또 어려워져서 고민을 하다 결국 솔루션을 찾아보았는데 `0-1 BFS` 라는 새로운 문제해결 방식에 대해 알게 되었다.

# 마무리
최단경로를 찾을 때는 다익스트라 알고리즘을 사용할 수 있지만, 시간복잡도가 `O(ElogV)`인 다익스트라와 다르게 `O(V+E)`의 시간복잡도로 구현이 가능하므로, 알고 있으면 매우 유용할 것 같다. 하지만 아직 100% 이해가 되지 않아서 나중에 복습할 필요가 있다.

거의 똑같은 숨바꼭질 문제인줄 알고 만만히 보고 덤볐다가 큰코 다쳤다...