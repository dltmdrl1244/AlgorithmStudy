# 문제
링크 : [1011 Fly me to the Alpha Centauri](https://www.acmicpc.net/problem/1011)

해결여부 : yes

# 문제 풀이
> 함수 공식만 찾으면 된다
- 모든 움직임은 1로 시작해서 1로 끝난다.
- 움직임당 차이는 최대 1이다. 1, 2, 3, 3, 2, 1 이런 식
- 1부터 n까지 올라갔다가 찍고 내려오면(`1, 2, ... n-1, n, n-1, ... 2, 1`) 이동 거리는 총 `n^2`이다
- 그리고 `n^2`에서 모자란 만큼은 적절하게 숫자를 끼워 넣음으로써 얼마든지 만들 수 있다. 예를 들어 40만큼 이동해야 한다면 먼저 6^2인 36을 만들고 부족한 4만큼 한 번 더 움직여서 `1 2 3 4 4 5 6 5 4 3 2 1` 이런 식으로 움직이면 된다. 이렇게 추가해줘야 하는 움직임의 횟수는 n으로 나눈 몫을 올림한 값
- 하나 고려해 줘야 하는 점이 n+1의 경우와도 비교해보아야 한다는 점이다. 예를 들어 97의 경우에는 9^2인 81과 10^2인 100 사이라서 81에서 19만큼을 더해 (9, 9, 3) `1 2 3 3 4 5 6 7 8 9 9 9 8 7 6 5 4 3 2 1` 이라고 생각할 수 있지만 사실 10에서 3만큼만 뒤로 가면 더 빠른 시행만에 가능하다. `1 2 3 3(뒤로이동) 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1` `즉 n^2이 거리를 넘지 않는 n을 찾은 후, n과 n+1을 비교해서 더 작은 값을 사용한다.`

---
- 처음에는 DP를 이용해서 `dp[i][j] = i좌표를 마지막이동을 j칸 이동해서 도착하는 최단횟수` 이런 식으로 해야하나 싶었지만 그러기엔 j 범위를 어디까지 잡아야 할지 모호했고 애초에 좌표 범위가 `2^31`이라서 배열처럼 관리하는 것은 불가능했다.
- 다음은 BFS를 이용하려 했는데 방문처리를 할 때 직전이동의 거리를 함께 저장해야 하는데 인덱스로 관리하기가 어려웠고, 애초에 범위도 너무 컸다.

# 마무리
함수를 찾는게 좀 어렵긴 했다. 처음에는 BFS나 DP인줄 알았음. 터무니없이 큰 수까지를 범위로 잡는다면 단순히 수식 해결 문제일 가능성이 크다는 사실을 생각하자