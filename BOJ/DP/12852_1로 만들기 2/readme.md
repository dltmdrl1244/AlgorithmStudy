# 문제
링크 : https://www.acmicpc.net/problem/12852
해결여부 : yes

# 코드
```
n = int(input())
dp = [float('inf')] * 1000001

dp[1] = 0

def recur(n):
    print(n, end=" ")
    if dp[n-1] == dp[n] - 1:
        recur(n-1)
    elif n % 3 == 0 and dp[n//3] == dp[n] - 1:
        recur(n//3)
    elif n % 2 == 0 and dp[n//2] == dp[n] - 1:
        recur(n//2)


for i in range(2, n+1):
    dp[i] = min(dp[i-1] + 1, dp[i])
    if i % 3 == 0:
        dp[i] = min(dp[i//3] + 1, dp[i])
    if i % 2 == 0:
        dp[i] = min(dp[i//2] + 1, dp[i])
        
print(dp[n])
recur(n)
```

# 문제 풀이
3으로 나누거나, 2로 나누거나, 1로 빼는 작업을 거쳐서 숫자를 1로 만들고, 만들 때 필요한 최소 횟수와 그 방법의 경로를 출력해야 한다.

결국 1로 만들어야 한다. 그럼 그 1은 어디에서 왔나? 자연수 `n`에서 파생되어 만들 수 있는 수가 `n//3`, `n//2`, `n-1`이다. 즉 1을 만들 수 있는 수는 `2`와 `3`이다.

그럼 그 2와 3은, `1을 1로 만드는 데 필요한 최소 연산 횟수` 보다 1이 큰 수를 최소 연산 횟수로 가질 것이다. 그리고 3은 또다시 4, 6, 또는 9에서부터 만들 수 있다.
반대로 생각하면 `3을 1로 만드는 데 필요한 최소 연산 횟수` 를 안다면, 마찬가지로 `4, 6, 9를 1로 만드는 데 필요한 최소 연산 횟수` 를 알 수 있다. 이런 식으로 1부터 채워 나가면, 모든 숫자에 대하여 그 숫자롤 1로 만드는 데 필요한 연산 횟수를 알 수 있다. 연산들 중 하나가 1을 더하는 연산이 있으므로 빈틈이 없이 채워진다.

일단 모든 dp 배열을 양의 무한대로 초기화시키고, 1을 1로 만드는 데 필요한 연산 횟수는 0이므로 `dp[1]`에 0을 넣음으로써 시작한다.

그리고 다음 2부터 n까지에 대해, 이전까지의 값들을 기반으로 연산을 수행한다. 일단 1 작은 수와 비교하는 것을 디폴트로 하여, 2의 배수일 때는 2로 나눈 수, 3의 배수일 때는 3으로 나눈 수를 추가적으로 비교한다. 최종적으로는 1~3번의 비교 연산을 수행하면서 가장 최솟값이 들어가게끔 한다. 시작 `dp[1]`이 0이었고 초기값이 양의 무한대이므로 기본적으로 한 번은 무조건 갱신이 가능하다.

이제는 그 수를 1로 만드는 방법(경로)을 알아내어 출력해야 한다.
만약 n이 10이라고 하면, 경로는 `10 9 3 1` 이고 답은 3이다.

`dp[3]`은 1이었다.
`dp[9]`은 2였다.
`dp[10]`은 3이다.

반대로 쓰면 더 잘 보인다.

`dp[10]`은 3이다.
`dp[9]`은 2였다.
`dp[3]`은 1이었다.

>어떤 수 n에 대해, dp[n-1] 또는 dp[n//3] 또는 dp[n//2](3, 2의 배수일 경우) 중 하나에는 무조건 dp[n]보다 1 작은 수가 있다.

당연하다. 왜냐면 `dp[n]`이 저 3개 수 중에 하나에서 1을 더함으로써 만들어졌기 때문이다.
그리고 `dp` 값이 1이 적다는 것은 곧, 1로 만드는 경로 상에 있다고 볼 수 있다.

즉 `n`부터 시작하여 `dp[n-1], dp[n//2], dp[n//3]` 을 보면서 재귀적으로 다음 n을 줄여가면서 출력하면, 1까지의 경로를 출력할 수 있다. 위 코드에서는 `recur` 이라는 이름의 재귀함수로 사용했다.

# 부족했던 점

# 마무리
범위가 10의 6제곱(백만)까지였는데, 10의 6제곱이 십만인 줄 알고 10만으로 초기화했다가 계속 IndexError가 왜 뜨는지 찾느라 10분을 허비했다는 비화가 있다 'ㅅa'