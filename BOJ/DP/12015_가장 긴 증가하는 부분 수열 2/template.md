# 문제
링크 : [12015 가장 긴 증가하는 부분 수열 2](https://www.acmicpc.net/problem/12015)

해결여부 : No

# 문제 풀이
다음은 가장 긴 증가하는 부분 수열을 구하는 쉬운 방법이다.
- `처음부터 자신까지의 수 중에서 자신이 몇 번째로 큰 숫자인지` 를 구한다.
- 배열을 순회하면서 i번째 원소 a에 대해
- 배열의 처음부터 i-1번째까지의 원소 k를 모두 탐색하면서, a보다 작은 k를 만나면 그 k가 가진 `dp` 값에 1을 더한 값들 중 최댓값으로 갱신한다.

이를 코드로 표현하면 다음과 같다:
```python
for i in range(n) :
    dp[i] = 1
    for j in range(n) :
        if arr[i] > arr[j] :
            dp[i] = max(dp[i], dp[j] + 1)
```

이 방법은 어떤 원소 i가 지금까지 살펴본 수 들 중에 몇 번째로 큰 숫자인지 직관적으로 찾을 수 있지만, 각 원소 하나에 대해 0~N-1개의 원소를 모두 살펴보아야 하므로 전체 수행의 시간 복잡도는 `O(N^2)` 이므로 비효율적이다.

---

이 문제는 배열의 길이 제한이 < 1,000,000 이므로 위와 같은 방법으로는 풀 수 없다. 다음은 이분 탐색(Binary search)를 이용해서 효과적으로 `NlogN` 시간 안에 푸는 방법이다.

`LIS` 배열을 만들고, `LIS[i]`를 정의하기를 `1~i까지의 원소를 살펴 보았을 때 i번째로 큰 수들 중에서 가장 작은 수` 라고 정의한다.

이렇게 하는 이유는, '지금 살펴보고 있는 원소의 서열이 지금까지 구한 답보다 작아서 의미가 없어 보일지라도, 나중에 그 원소로부터 시작하는 더 긴 부분수열이 답이 될 수 있기 때문'이다.

예를 들어 `[10, 97, 98, 99, 11, 12, 13, 14]` 의 배열을 살펴보면 99까지 살펴보았을 때 현재 가장 긴 부분 수열의 길이는 4이지만 답은 `[10, 11, 12, 13, 14]`의 5이다.
즉 99 뒤에 나타나는 11, 12, 13에 대해 무시할 수 없다는 것이다.

포인트는 '가장 큰 숫자' 이외에도 '현재 몇 번째로 작은 수는 어떤 수인지' 를 함께 저장하는 것이다. 앞서 99까지 살펴보았을 때 2번째로 작은 수는 97이다. 이 때 11이 들어왔다고 하면 11은 2번째로 작은 수이다. 이 때 그럼 `97을 3번째로 작은 수로 만들어서 한 칸씩 미는 것이 아니고 97 자리를 11로 교체하는 작업`을 거친다. 전체 LIS의 길이를 지키기 위해서이다. 어차피 '가장 긴 부분 수열의 길이'를 구하는 것이므로 구하는 과정에서 어떤 수가 부분 수열을 구성하고 있는지는 관심이 없다.

LIS 배열 안의 숫자들은 작으면 작을수록 뒤에 나타나는 숫자들이 들어올 가능성이 높으므로, 어떤 숫자가 들어올 자리에 자신보다 큰 숫자가 자리하고 있다면 그 숫자 자리를 덮어씌우게 된다. 즉 위와 같은 예시에서 12까지 탐색 하였을 때는 `LIS` 배열은 `[10, 11, 12, 99]` 이며 13을 탐색했을 때 `[10, 11, 12, 13]` 이 되고, 이어 14를 탐색했을 때는 가장 큰 숫자보다 크므로 뒤에다 append 하여 `[10, 11, 12, 13, 14]` 가 답이 된다.

# 마무리
[도움 받은 글 링크](https://velog.io/@ledcost/백준-12015-파이썬-가장-긴-증가하는-부분-수열-2-골드2-이분-탐색)

처음에는 '어떤 수가 몇 번째로 큰지 logN만에 알 수 있는 방법이 없나' 를 생각하느라 답을 찾는 데 힘듦을 겪었다.